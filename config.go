// Copyright (c) 2025 Vojtech Pavlik <vojtech@suse.com>
//
// Created using AI tools
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

// Package main provides the configuration structures and parsing logic for the
// Unified Core MCP server. It handles reading the simple-mcp.yaml file which defines
// the static resources and executable tools exposed to the LLM.
package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"gopkg.in/yaml.v3"
)

// ContextItem defines a single dynamic context source (Tool) exposed to the LLM.
// Tools are executable commands that can accept parameters.
type ContextItem struct {
	Name           string   `yaml:"name"`
	Description    string   `yaml:"description"`
	Command        string   `yaml:"command"`
	TimeoutSeconds int      `yaml:"timeoutSeconds,omitempty"`
	Parameters     []string `yaml:"parameters,omitempty"`
	Async          bool     `yaml:"async,omitempty"`
}

// ResourceItem defines a system resource exposed via the MCP Resources capability.
// These can be static text content or dynamic content generated by a command.
type ResourceItem struct {
	URI             string `yaml:"uri"`
	Description     string `yaml:"description"`
	Command         string `yaml:"command,omitempty"`
	IntervalSeconds int    `yaml:"intervalSeconds,omitempty"`
	Content         string `yaml:"content,omitempty"`
	ContentFile     string `yaml:"contentFile,omitempty"`
	Directory       string `yaml:"directory,omitempty"`
}

// Spec defines the schema for the configuration file.
type Spec struct {
	LegacyItems []ContextItem  `yaml:"contextItems,omitempty"`
	Tools       []ContextItem  `yaml:"tools,omitempty"`
	Resources   []ResourceItem `yaml:"resources"`
	ListenAddr    string         `yaml:"listenAddr,omitempty"`
	TmpDir        string         `yaml:"tmpDir,omitempty"`
	Verbose       *bool          `yaml:"verbose,omitempty"`
	MaxAsyncTasks int            `yaml:"maxAsyncTasks,omitempty"`
}

// Config represents the top-level structure of the simple-mcp.yaml file.
type Config struct {
	APIVersion string `yaml:"apiVersion"`
	Kind       string `yaml:"kind"`
	Metadata   struct {
		Name string `yaml:"name"`
	} `yaml:"metadata"`
	Specification Spec `yaml:"spec"`
}

var yamlLineRegex = regexp.MustCompile(`line (\d+):`)

// formatYamlError enriches the standard YAML error with context from the file,
// printing the problematic line and its neighbors to aid debugging.
func formatYamlError(path string, fileData []byte, err error) error {
	var yamlErr *yaml.TypeError
	if !errors.As(err, &yamlErr) {
		return fmt.Errorf("failed to parse YAML from %s: %w", path, err)
	}

	matches := yamlLineRegex.FindStringSubmatch(err.Error())
	if len(matches) < 2 {
		return fmt.Errorf("failed to parse YAML from %s:\n%w", path, err)
	}

	lineNum, _ := strconv.Atoi(matches[1])
	lines := bytes.Split(fileData, []byte("\n"))

	var newErr strings.Builder
	fmt.Fprintf(&newErr, "failed to parse YAML from %s (line %d):\n", path, lineNum)
	fmt.Fprintf(&newErr, "  Error: %s\n", err.Error())
	if lineNum > 0 && lineNum <= len(lines) {
		if lineNum > 1 {
			fmt.Fprintf(&newErr, "%5d | %s\n", lineNum-1, lines[lineNum-2])
		}
		fmt.Fprintf(&newErr, ">>%4d | %s <<\n", lineNum, lines[lineNum-1])
		if lineNum < len(lines) {
			fmt.Fprintf(&newErr, "%5d | %s\n", lineNum+1, lines[lineNum])
		}
	}
	return errors.New(newErr.String())
}

// LoadConfig reads and parses the YAML configuration file from the given path.
func LoadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file %s: %w", path, err)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, formatYamlError(path, data, err)
	}

	if len(config.Specification.LegacyItems) > 0 && len(config.Specification.Tools) > 0 {
		return nil, fmt.Errorf("failed to parse %s: both 'contextItems' and 'tools' are defined in 'spec', please use only 'tools'", path)
	}

	// If 'contextItems' is used, move them to 'Tools' to standardize on the new name.
	if len(config.Specification.LegacyItems) > 0 {
		config.Specification.Tools = config.Specification.LegacyItems
		config.Specification.LegacyItems = nil // Clear LegacyItems to avoid confusion
	}

	// Get the directory of the config file to resolve relative paths
	configDir := filepath.Dir(path)

	var expandedResources []ResourceItem
	for _, resource := range config.Specification.Resources {
		if resource.Directory != "" {
			dirPath := resource.Directory
			if !filepath.IsAbs(dirPath) {
				dirPath = filepath.Join(configDir, dirPath)
			}
			err := filepath.WalkDir(dirPath, func(path string, d os.DirEntry, err error) error {
				if err != nil {
					return err
				}
				if d.IsDir() {
					return nil
				}
				relPath, err := filepath.Rel(dirPath, path)
				if err != nil {
					return err
				}
				fileContent, err := os.ReadFile(path)
				if err != nil {
					return err
				}
				newURI := resource.URI
				if !strings.HasSuffix(newURI, "/") {
					newURI += "/"
				}
				newURI += strings.ReplaceAll(relPath, "\\", "/")

				newResource := resource
				newResource.URI = newURI
				newResource.Content = string(fileContent)
				newResource.Directory = "" // Clear the directory field to avoid re-expansion
				expandedResources = append(expandedResources, newResource)
				return nil
			})
			if err != nil {
				return nil, fmt.Errorf("failed to walk directory for resource %s: %w", resource.URI, err)
			}
		} else {
			if resource.ContentFile != "" {
				contentFilePath := resource.ContentFile
				if !filepath.IsAbs(contentFilePath) {
					contentFilePath = filepath.Join(configDir, contentFilePath)
				}
				fileContent, err := os.ReadFile(contentFilePath)
				if err != nil {
					return nil, fmt.Errorf("failed to read content file for resource %s: %w", resource.URI, err)
				}
				// Append file content to existing content
				resource.Content = resource.Content + string(fileContent)
			}
			expandedResources = append(expandedResources, resource)
		}
	}
	config.Specification.Resources = expandedResources

	return &config, nil
}
